name: Release

on:
  push:
    tags:
      - "*"
  workflow_dispatch:
    inputs:
      tag_name:
        description: "Release tag (æ‰‹åŠ¨è¿è¡Œå¯è‡ªå®šä¹‰ï¼Œç•™ç©ºåˆ™ä½¿ç”¨ manual-<short_sha>)"
        required: false
        default: ""
      release_name:
        description: "Release åç§°ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸ tag ç›¸åŒï¼‰"
        required: false
        default: ""
      prerelease:
        description: "æ˜¯å¦æ ‡è®°ä¸º Pre-releaseï¼ˆæ‰‹åŠ¨è¿è¡Œé»˜è®¤ trueï¼‰"
        required: false
        default: "false"
      create_release:
        description: "æ˜¯å¦åˆ›å»º GitHub Releaseï¼ˆæ‰‹åŠ¨è¿è¡Œå¯è®¾ä¸º falseï¼Œä»…æ„å»ºä¸äº§å‡º Actions Artifactsï¼‰"
        required: false
        default: "true"

# å…è®¸å–æ¶ˆæ­£åœ¨è¿è¡Œçš„workflow
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

env:
  FLUTTER_VERSION: "3.27.3"

jobs:
  check-branch:
    name: Check if main branch
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Check branch
        run: |
          if [ "${{ github.ref_name }}" != "main" ]; then
            echo "âŒ Release workflow can only be triggered from main branch"
            echo "Current branch: ${{ github.ref_name }}"
            exit 1
          fi
          echo "âœ… Branch check passed: ${{ github.ref_name }}"

  android:
    name: Android (APK + AAB)
    runs-on: ubuntu-latest
    needs: [check-branch]
    if: always() && (needs.check-branch.result == 'success' || github.event_name == 'push')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Prepare release metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          IS_TAG="false"
          TAG_NAME=""
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            IS_TAG="true"
            TAG_NAME="${GITHUB_REF#refs/tags/}"
          fi
          if [[ -z "$TAG_NAME" ]]; then
            INPUT_TAG="${{ github.event.inputs.tag_name || '' }}"
            if [[ -n "$INPUT_TAG" ]]; then
              TAG_NAME="$INPUT_TAG"
            else
              SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-7)
              TAG_NAME="manual-${SHORT_SHA}"
            fi
          fi
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: "zulu"
          java-version: "17"

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Install Android build-tools and platforms
        run: |
          sdkmanager --install "platform-tools" "platforms;android-35" "build-tools;35.0.0"

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: "stable"
          cache: true

      - name: Flutter pub get
        run: flutter pub get

      - name: Setup Android signing from secrets (optional)
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
        run: |
          set -euo pipefail
          if [ -n "${ANDROID_KEYSTORE_BASE64:-}" ]; then
            echo "Writing Android keystore from secret..."
            mkdir -p android/app
            echo "$ANDROID_KEYSTORE_BASE64" | base64 -d > android/app/ci-release.keystore
            printf '%s\n' \
              'storeFile=ci-release.keystore' \
              "storePassword=${ANDROID_KEYSTORE_PASSWORD}" \
              "keyAlias=${ANDROID_KEY_ALIAS}" \
              "keyPassword=${ANDROID_KEY_PASSWORD}" \
              > android/key.properties
            echo "key.properties created."
          else
            echo "No Android signing secrets provided; will use fallback CI keystore in Gradle."
          fi

      - name: Update pubspec.yaml version
        run: |
          VERSION='${{ steps.meta.outputs.tag_name }}'
          echo "Updating pubspec.yaml version to: $VERSION"
          # å¤‡ä»½åŸå§‹ pubspec.yaml
          cp pubspec.yaml pubspec.yaml.backup
          # æ›´æ–°ç‰ˆæœ¬å·ï¼Œä¿æŒæ„å»ºå·é€’å¢
          # ä»æ ‡ç­¾ä¸­æå–ç‰ˆæœ¬å·ï¼ˆå»æ‰ v å‰ç¼€ï¼‰
          CLEAN_VERSION=${VERSION#v}
          # ç”Ÿæˆæ„å»ºå·ï¼ˆä½¿ç”¨ GitHub run numberï¼‰
          BUILD_NUMBER=${{ github.run_number }}
          # æ›´æ–° pubspec.yaml
          sed -i "s/^version: .*/version: ${CLEAN_VERSION}+${BUILD_NUMBER}/" pubspec.yaml
          echo "Updated version in pubspec.yaml:"
          grep "^version:" pubspec.yaml

      - name: Build APK (release)
        run: |
          export CI_VERSION='${{ steps.meta.outputs.tag_name }}'
          export GIT_COMMIT='${{ github.sha }}'
          export BUILD_TIME='${{ github.run_id }}'
          echo "Debug: CI_VERSION=$CI_VERSION"
          echo "Debug: TAG_NAME=${{ steps.meta.outputs.tag_name }}"
          flutter build apk --release --flavor prod \
            --dart-define=CI_VERSION="$CI_VERSION" \
            --dart-define=GIT_COMMIT="$GIT_COMMIT" \
            --dart-define=BUILD_TIME="$BUILD_TIME"

      - name: Build App Bundle (AAB)
        run: |
          export CI_VERSION='${{ steps.meta.outputs.tag_name }}'
          export GIT_COMMIT='${{ github.sha }}'
          export BUILD_TIME='${{ github.run_id }}'

          # For Google Play: remove REQUEST_INSTALL_PACKAGES permission
          # Google Play handles updates automatically, so in-app APK installation is not needed
          mkdir -p android/app/src/prod
          cat > android/app/src/prod/AndroidManifest.xml << 'MANIFEST_EOF'
          <manifest xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools">
              <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES"
                  tools:node="remove" />
          </manifest>
          MANIFEST_EOF

          flutter build appbundle --release --flavor prod \
            --dart-define=CI_VERSION="$CI_VERSION" \
            --dart-define=GIT_COMMIT="$GIT_COMMIT" \
            --dart-define=BUILD_TIME="$BUILD_TIME" \
            --dart-define=GOOGLE_PLAY=true

          # Cleanup: remove the temporary manifest so it doesn't affect other builds
          rm -rf android/app/src/prod

      - name: List Android outputs (debug)
        run: |
          echo "== build/app/outputs =="
          ls -R build/app/outputs || true
          echo "== flutter-apk =="
          ls -la build/app/outputs/flutter-apk || true
          echo "== bundle =="
          ls -R build/app/outputs/bundle || true

      - name: Rename Android artifacts with version
        run: |
          VERSION="${{ steps.meta.outputs.tag_name }}"
          cd build/app/outputs
          # é‡å‘½å APK
          if [ -f flutter-apk/app-prod-release.apk ]; then
            mv flutter-apk/app-prod-release.apk flutter-apk/beecount-${VERSION}.apk
            echo "Renamed APK to: beecount-${VERSION}.apk"
          fi
          # é‡å‘½å AAB
          if [ -f bundle/prodRelease/app-prod-release.aab ]; then
            mv bundle/prodRelease/app-prod-release.aab bundle/prodRelease/beecount-${VERSION}.aab
            echo "Renamed AAB to: beecount-${VERSION}.aab"
          fi
          echo "=== Final Android artifacts ==="
          find . -name "*.apk" -o -name "*.aab"

      - name: Upload Android artifacts
        uses: actions/upload-artifact@v4
        with:
          name: android
          if-no-files-found: error
          path: |
            build/app/outputs/flutter-apk/beecount-*.apk
            build/app/outputs/bundle/prodRelease/beecount-*.aab

      - name: Upload AAB to Google Play Console
        if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) || github.event_name == 'workflow_dispatch'
        env:
          GOOGLE_PLAY_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT_JSON }}
        run: |
          VERSION="${{ steps.meta.outputs.tag_name }}"
          AAB_FILE="build/app/outputs/bundle/prodRelease/beecount-${VERSION}.aab"

          if [ -z "${GOOGLE_PLAY_SERVICE_ACCOUNT_JSON:-}" ]; then
            echo "âš ï¸  GOOGLE_PLAY_SERVICE_ACCOUNT_JSON not set, skipping Google Play upload"
            exit 0
          fi

          if [ ! -f "$AAB_FILE" ]; then
            echo "âŒ AAB file not found: $AAB_FILE"
            exit 1
          fi

          echo "ğŸ“¤ Uploading $AAB_FILE to Google Play Console..."

          # ä¿å­˜æœåŠ¡è´¦æˆ· JSON åˆ°ä¸´æ—¶æ–‡ä»¶
          echo "$GOOGLE_PLAY_SERVICE_ACCOUNT_JSON" > /tmp/service-account.json

          # ä½¿ç”¨ Google Play Developer API ä¸Šä¼ 
          # å®‰è£… google-play CLI å·¥å…·
          pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client

          # åˆ›å»ºä¸Šä¼ è„šæœ¬
          cat > /tmp/upload_to_play.py << 'UPLOAD_SCRIPT'
          import sys
          import json
          from google.oauth2 import service_account
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaFileUpload

          # é…ç½®
          PACKAGE_NAME = 'com.tntlikely.beecount'
          AAB_FILE = sys.argv[1]
          TRACK = 'production'  # internal, alpha, beta, production

          # è®¤è¯
          credentials = service_account.Credentials.from_service_account_file(
              '/tmp/service-account.json',
              scopes=['https://www.googleapis.com/auth/androidpublisher']
          )

          # åˆ›å»º API å®¢æˆ·ç«¯
          service = build('androidpublisher', 'v3', credentials=credentials)

          try:
              # åˆ›å»ºç¼–è¾‘
              edit = service.edits().insert(body={}, packageName=PACKAGE_NAME).execute()
              edit_id = edit['id']
              print(f"âœ… Created edit: {edit_id}")

              # ä¸Šä¼  AAB
              media = MediaFileUpload(AAB_FILE, mimetype='application/octet-stream', resumable=True)
              bundle = service.edits().bundles().upload(
                  packageName=PACKAGE_NAME,
                  editId=edit_id,
                  media_body=media
              ).execute()
              version_code = bundle['versionCode']
              print(f"âœ… Uploaded AAB, version code: {version_code}")

              # åˆ†é…åˆ°è½¨é“
              track_body = {
                  'releases': [{
                      'versionCodes': [version_code],
                      'status': 'completed'
                  }]
              }
              service.edits().tracks().update(
                  packageName=PACKAGE_NAME,
                  editId=edit_id,
                  track=TRACK,
                  body=track_body
              ).execute()
              print(f"âœ… Assigned to {TRACK} track")

              # æäº¤ç¼–è¾‘
              service.edits().commit(packageName=PACKAGE_NAME, editId=edit_id).execute()
              print("âœ… Changes committed to Google Play Console!")

          except Exception as e:
              print(f"âŒ Upload failed: {e}")
              sys.exit(1)
          UPLOAD_SCRIPT

          python /tmp/upload_to_play.py "$AAB_FILE"

          # æ¸…ç†
          rm -f /tmp/service-account.json /tmp/upload_to_play.py

          echo "âœ… Successfully uploaded to Google Play Console (alpha track)!"

  ios:
    name: iOS (app.zip + unsigned .ipa)
    runs-on: macos-latest
    needs: [check-branch]
    if: always() && (needs.check-branch.result == 'success' || github.event_name == 'push')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Prepare release metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          IS_TAG="false"
          TAG_NAME=""
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            IS_TAG="true"
            TAG_NAME="${GITHUB_REF#refs/tags/}"
          fi
          if [[ -z "$TAG_NAME" ]]; then
            INPUT_TAG="${{ github.event.inputs.tag_name || '' }}"
            if [[ -n "$INPUT_TAG" ]]; then
              TAG_NAME="$INPUT_TAG"
            else
              SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-7)
              TAG_NAME="manual-${SHORT_SHA}"
            fi
          fi
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Select latest Xcode
        run: |
          echo "ğŸ“± Available Xcode versions:"
          ls -la /Applications/ | grep Xcode || true

          # é€‰æ‹©æœ€æ–°çš„ Xcode ç‰ˆæœ¬ (åŒ…å« iOS 26 SDK)
          LATEST_XCODE=$(ls -d /Applications/Xcode*.app 2>/dev/null | sort -V | tail -1)
          if [ -n "$LATEST_XCODE" ]; then
            echo "ğŸ”§ Selecting Xcode: $LATEST_XCODE"
            sudo xcode-select -s "$LATEST_XCODE"
          fi

          echo ""
          echo "ğŸ“‹ Current Xcode version:"
          xcodebuild -version

          echo ""
          echo "ğŸ“‹ Available iOS SDKs:"
          xcodebuild -showsdks | grep -i ios || true

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: "stable"
          cache: false

      # æ‰‹åŠ¨ç¼“å­˜ pub ä¾èµ–
      - name: Cache pub dependencies
        uses: actions/cache@v4
        with:
          path: ~/.pub-cache
          key: pub-${{ runner.os }}-${{ env.FLUTTER_VERSION }}-${{ github.sha }}
          restore-keys: |
            pub-${{ runner.os }}-${{ env.FLUTTER_VERSION }}-

      - name: Flutter pub get
        run: flutter pub get

      - name: Update pubspec.yaml version (iOS)
        run: |
          VERSION='${{ steps.meta.outputs.tag_name }}'
          echo "Updating pubspec.yaml version to: $VERSION"
          # å¤‡ä»½åŸå§‹ pubspec.yaml
          cp pubspec.yaml pubspec.yaml.backup
          # æ›´æ–°ç‰ˆæœ¬å·ï¼Œä¿æŒæ„å»ºå·é€’å¢
          # ä»æ ‡ç­¾ä¸­æå–ç‰ˆæœ¬å·ï¼ˆå»æ‰ v å‰ç¼€ï¼‰
          CLEAN_VERSION=${VERSION#v}
          # ç”Ÿæˆæ„å»ºå·ï¼ˆä½¿ç”¨ GitHub run numberï¼‰
          BUILD_NUMBER=${{ github.run_number }}
          # æ›´æ–° pubspec.yaml
          sed -i "" "s/^version: .*/version: ${CLEAN_VERSION}+${BUILD_NUMBER}/" pubspec.yaml
          echo "Updated version in pubspec.yaml:"
          grep "^version:" pubspec.yaml

      - name: Setup iOS signing (optional)
        env:
          IOS_P12_BASE64: ${{ secrets.APPLE_CERTIFICATE_P12 }}
          IOS_P12_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          IOS_PROVISION_PROFILE_BASE64: ${{ secrets.APPLE_PROVISIONING_PROFILE }}
          IOS_WIDGET_PROVISION_PROFILE_BASE64: ${{ secrets.APPLE_PROVISIONING_PROFILE_WIDGET }}
          IOS_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          if [ -n "${IOS_P12_BASE64:-}" ]; then
            echo "ğŸ“± Setting up iOS code signing from secrets..."

            # åˆ›å»ºä¸´æ—¶keychain
            KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
            KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

            security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
            security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

            # å¯¼å…¥è¯ä¹¦
            CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
            echo "$IOS_P12_BASE64" | base64 -d > $CERTIFICATE_PATH
            security import $CERTIFICATE_PATH -P "$IOS_P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
            security list-keychain -d user -s $KEYCHAIN_PATH

            # å®‰è£…provisioning profile
            PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
            echo "$IOS_PROVISION_PROFILE_BASE64" | base64 -d > $PP_PATH

            # ä» provisioning profile ä¸­æå– UUID
            PP_UUID=$(security cms -D -i $PP_PATH | plutil -extract UUID raw -)
            echo "Provisioning Profile UUID: $PP_UUID"

            # ä½¿ç”¨ UUID ä½œä¸ºæ–‡ä»¶åå®‰è£…åˆ°æ­£ç¡®ä½ç½®
            mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
            cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles/${PP_UUID}.mobileprovision
            echo "âœ… Installed provisioning profile: ${PP_UUID}.mobileprovision"

            # å®‰è£…Widget Extension provisioning profile
            if [ -n "${IOS_WIDGET_PROVISION_PROFILE_BASE64:-}" ]; then
              WIDGET_PP_PATH=$RUNNER_TEMP/build_widget_pp.mobileprovision
              echo "$IOS_WIDGET_PROVISION_PROFILE_BASE64" | base64 -d > $WIDGET_PP_PATH
              WIDGET_PP_UUID=$(security cms -D -i $WIDGET_PP_PATH | plutil -extract UUID raw -)
              echo "Widget Provisioning Profile UUID: $WIDGET_PP_UUID"
              cp $WIDGET_PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles/${WIDGET_PP_UUID}.mobileprovision
              echo "âœ… Installed widget provisioning profile: ${WIDGET_PP_UUID}.mobileprovision"

              # è°ƒè¯•ï¼šæ˜¾ç¤º widget provisioning profile è¯¦ç»†ä¿¡æ¯
              echo "ğŸ“‹ Widget Provisioning Profile details:"
              security cms -D -i $WIDGET_PP_PATH | plutil -p - | grep -A 5 -E "(Name|UUID|TeamIdentifier|AppIDName)"
            else
              echo "âš ï¸  No Widget Extension provisioning profile provided"
            fi

            # è°ƒè¯•ï¼šæ˜¾ç¤ºä¸»åº”ç”¨ provisioning profile è¯¦ç»†ä¿¡æ¯
            echo "ğŸ“‹ Main App Provisioning Profile details:"
            security cms -D -i $PP_PATH | plutil -p - | grep -A 5 -E "(Name|UUID|TeamIdentifier|AppIDName)"

            # è®¾ç½® codesign æƒé™
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

            # è°ƒè¯•ï¼šåˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„ç­¾åèº«ä»½
            echo "ğŸ“‹ Available signing identities in keychain:"
            security find-identity -v -p codesigning $KEYCHAIN_PATH

            echo ""
            echo "ğŸ“‹ All signing identities on system:"
            security find-identity -v -p codesigning

            # åŠ¨æ€ç”Ÿæˆ ExportOptions.plistï¼ˆä½¿ç”¨ printf é¿å… heredoc YAML å†²çªï¼‰
            printf '%s\n' \
              '<?xml version="1.0" encoding="UTF-8"?>' \
              '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' \
              '<plist version="1.0">' \
              '<dict>' \
              '    <key>method</key>' \
              '    <string>app-store</string>' \
              '    <key>teamID</key>' \
              "    <string>${IOS_TEAM_ID}</string>" \
              '    <key>uploadBitcode</key>' \
              '    <false/>' \
              '    <key>uploadSymbols</key>' \
              '    <true/>' \
              '    <key>signingStyle</key>' \
              '    <string>manual</string>' \
              '    <key>signingCertificate</key>' \
              '    <string>Apple Distribution</string>' \
              '    <key>provisioningProfiles</key>' \
              '    <dict>' \
              '        <key>com.tntlikely.beecount</key>' \
              '        <string>BeeCount_AppStore</string>' \
              '        <key>com.tntlikely.beecount.BeeCountWidgetExtension</key>' \
              '        <string>BeeCount_Widget_AppStore</string>' \
              '    </dict>' \
              '</dict>' \
              '</plist>' \
              > ios/ExportOptions.plist

            echo "âœ… iOS signing configured"
            echo "IOS_SIGNING_ENABLED=true" >> $GITHUB_ENV
          else
            echo "âš ï¸  No iOS signing secrets provided; will build unsigned only"
            echo "IOS_SIGNING_ENABLED=false" >> $GITHUB_ENV
          fi

      - name: Build iOS (no codesign)
        run: |
          export CI_VERSION='${{ steps.meta.outputs.tag_name }}'
          export GIT_COMMIT='${{ github.sha }}'
          export BUILD_TIME='${{ github.run_id }}'
          flutter build ios --release --no-codesign \
            --dart-define=CI_VERSION="$CI_VERSION" \
            --dart-define=GIT_COMMIT="$GIT_COMMIT" \
            --dart-define=BUILD_TIME="$BUILD_TIME"

      - name: Configure Xcode project for signing
        if: env.IOS_SIGNING_ENABLED == 'true'
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          PROJECT_FILE="ios/Runner.xcodeproj/project.pbxproj"

          echo "ğŸ”§ Configuring manual signing for iOS..."

          # 1. é…ç½®æ‰‹åŠ¨ç­¾å
          sed -i '' 's/CODE_SIGN_STYLE = Automatic;/CODE_SIGN_STYLE = Manual;/g' "$PROJECT_FILE"

          # 2. ä¿®æ”¹ç­¾åèº«ä»½ä¸ºå‘å¸ƒè¯ä¹¦
          sed -i '' 's/"CODE_SIGN_IDENTITY\[sdk=iphoneos\*\]" = "iPhone Developer";/"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "Apple Distribution";/g' "$PROJECT_FILE"

          # 3. ä¸ºä¸»åº”ç”¨å’ŒWidget Extensioné…ç½®Team IDå’ŒProvisioning Profile
          # å…ˆæ¸…é™¤æ‰€æœ‰ç°æœ‰çš„DEVELOPMENT_TEAMå’ŒPROVISIONING_PROFILE_SPECIFIERé…ç½®
          sed -i '' '/DEVELOPMENT_TEAM = /d' "$PROJECT_FILE"
          sed -i '' '/PROVISIONING_PROFILE_SPECIFIER = /d' "$PROJECT_FILE"

          # 4. ä½¿ç”¨perlä¸ºæ‰€æœ‰buildSettingsæ·»åŠ Team IDï¼ˆåŒ…æ‹¬ä¸»åº”ç”¨å’ŒWidget Extensionï¼‰
          perl -i -pe "s/(buildSettings = \\{)/\$1\n\t\t\t\tDEVELOPMENT_TEAM = ${APPLE_TEAM_ID};/g" "$PROJECT_FILE"

          # 5. ä¸ºWidget Extensionå’Œä¸»åº”ç”¨æ·»åŠ Provisioning Profileé…ç½®
          # ä½¿ç”¨perlè¿›è¡Œç²¾ç¡®åŒ¹é…å’Œæ’å…¥
          perl -i -pe '
            # Widget Extension: åœ¨å…¶Bundle IDè¡Œå‰æ’å…¥Profileé…ç½®
            if (/^\s+PRODUCT_BUNDLE_IDENTIFIER = com\.tntlikely\.beecount\.BeeCountWidgetExtension;/) {
              print "\t\t\t\tPROVISIONING_PROFILE_SPECIFIER = \"BeeCount_Widget_AppStore\";\n";
            }
            # ä¸»åº”ç”¨: ä¸»åº”ç”¨ä½¿ç”¨å˜é‡å½¢å¼çš„Bundle ID,é€šè¿‡CODE_SIGN_ENTITLEMENTSè¯†åˆ«
            elsif (/^\s+CODE_SIGN_ENTITLEMENTS = Runner\/Runner\.entitlements;/) {
              print "\t\t\t\tPROVISIONING_PROFILE_SPECIFIER = \"BeeCount_AppStore\";\n";
            }
          ' "$PROJECT_FILE"

          echo "âœ… Configured manual signing for Xcode project"

      - name: Build iOS archive with xcodebuild
        if: env.IOS_SIGNING_ENABLED == 'true'
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "ğŸ“¦ Building iOS archive..."

          # Archive the app (åªæ˜¾ç¤ºé”™è¯¯å’Œè­¦å‘Š,å‡å°‘æ—¥å¿—å™ªéŸ³)
          # å®Œå…¨ä¾èµ–project.pbxprojä¸­çš„é…ç½®
          if xcodebuild archive \
            -workspace ios/Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -archivePath build/ios/Runner.xcarchive \
            -quiet \
            2>&1 | grep -E "error:|warning:|note:|failed|succeeded" | tee xcodebuild-archive.log; then

            echo "âœ… Archive created successfully"
            ls -lh build/ios/Runner.xcarchive/Products/Applications/ 2>/dev/null || true
          else
            echo "âŒ Archive failed! Full log:"
            cat xcodebuild-archive.log
            exit 1
          fi

      - name: Export IPA from archive
        if: env.IOS_SIGNING_ENABLED == 'true'
        run: |
          echo "ğŸ“¤ Exporting IPA..."

          # Export IPA (åªæ˜¾ç¤ºå…³é”®ä¿¡æ¯)
          if xcodebuild -exportArchive \
            -archivePath build/ios/Runner.xcarchive \
            -exportPath build/ios/ipa \
            -exportOptionsPlist ios/ExportOptions.plist \
            -quiet \
            2>&1 | grep -E "error:|warning:|Exported|succeeded" | tee xcodebuild-export.log; then

            echo "âœ… IPA exported successfully"
            ls -lh build/ios/ipa/

            # éªŒè¯IPAæ–‡ä»¶
            if [ -f build/ios/ipa/*.ipa ]; then
              echo ""
              echo "IPA file details:"
              ls -lh build/ios/ipa/*.ipa

              # æ˜¾ç¤ºIPAç­¾åä¿¡æ¯
              echo ""
              echo "IPA signing info:"
              unzip -l build/ios/ipa/*.ipa | grep -E "Payload|PlugIns|\.app" | head -20
            else
              echo "âŒ Error: IPA file not found in build/ios/ipa/"
              exit 1
            fi
          else
            echo ""
            echo "âŒ Export failed. Check xcodebuild-export.log for details"
            echo "Last 50 lines of export log:"
            tail -50 xcodebuild-export.log
            exit 1
          fi

      - name: Copy signed IPA to release directory
        if: env.IOS_SIGNING_ENABLED == 'true'
        run: |
          set -euo pipefail
          VERSION="${{ steps.meta.outputs.tag_name }}"

          # flutter build ipa ä¼šåœ¨ build/ios/ipa ç›®å½•ç”Ÿæˆ IPA
          if [ -f build/ios/ipa/*.ipa ]; then
            cp build/ios/ipa/*.ipa beecount-${VERSION}-signed.ipa
            echo "âœ… Copied signed IPA: beecount-${VERSION}-signed.ipa"
            ls -lh beecount-${VERSION}-signed.ipa
          else
            echo "âŒ Signed IPA not found in build/ios/ipa/"
            ls -la build/ios/ipa/ || true
            exit 1
          fi

      - name: Cleanup iOS keychain
        if: always() && env.IOS_SIGNING_ENABLED == 'true'
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true

      - name: Build iOS (debug simulator, unsigned)
        run: |
          export CI_VERSION='${{ steps.meta.outputs.tag_name }}'
          export GIT_COMMIT='${{ github.sha }}'
          export BUILD_TIME='${{ github.run_id }}'
          flutter build ios --debug --simulator \
            --dart-define=CI_VERSION="$CI_VERSION" \
            --dart-define=GIT_COMMIT="$GIT_COMMIT" \
            --dart-define=BUILD_TIME="$BUILD_TIME"

      - name: Package iOS Runner.app (unsigned)
        run: |
          set -euo pipefail
          VERSION="${{ steps.meta.outputs.tag_name }}"
          APP_PATH="build/ios/iphoneos/Runner.app"
          if [ ! -d "$APP_PATH" ]; then
            echo "Runner.app not found at $APP_PATH" >&2
            ls -la build/ios/iphoneos || true
            exit 1
          fi
          # ç”ŸæˆåŒ…å«ç‰ˆæœ¬å·çš„æ–‡ä»¶å
          ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" beecount-${VERSION}-iphoneos.app.zip
          mkdir -p Payload
          cp -R "$APP_PATH" Payload/
          /usr/bin/zip -qry beecount-${VERSION}-unsigned.ipa Payload
          echo "Generated iOS artifacts:"
          ls -la beecount-${VERSION}-*

      - name: Package iOS Simulator Runner.app (debug, unsigned)
        run: |
          set -euo pipefail
          VERSION="${{ steps.meta.outputs.tag_name }}"
          SIM_APP_PATH="build/ios/iphonesimulator/Runner.app"
          if [ -d "$SIM_APP_PATH" ]; then
            ditto -c -k --sequesterRsrc --keepParent "$SIM_APP_PATH" beecount-${VERSION}-iphonesimulator.app.zip
            echo "Generated iOS Simulator artifact: beecount-${VERSION}-iphonesimulator.app.zip"
          else
            echo "Simulator Runner.app not found at $SIM_APP_PATH" >&2
            ls -la build/ios/iphonesimulator || true
          fi

      - name: Upload to TestFlight
        if: env.IOS_SIGNING_ENABLED == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          set -euo pipefail
          VERSION="${{ steps.meta.outputs.tag_name }}"
          IPA_FILE="beecount-${VERSION}-signed.ipa"

          if [ -z "${APPLE_ID:-}" ] || [ -z "${APPLE_APP_SPECIFIC_PASSWORD:-}" ]; then
            echo "âš ï¸  APPLE_ID or APPLE_APP_SPECIFIC_PASSWORD not set, skipping TestFlight upload"
            exit 0
          fi

          if [ ! -f "$IPA_FILE" ]; then
            echo "âŒ Signed IPA not found: $IPA_FILE"
            exit 1
          fi

          echo "ğŸ“¤ Uploading $IPA_FILE to TestFlight..."
          xcrun altool --upload-app \
            --type ios \
            --file "$IPA_FILE" \
            --username "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --verbose

          echo "âœ… Successfully uploaded to TestFlight!"

      - name: Upload iOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ios
          path: |
            beecount-*-iphoneos.app.zip
            beecount-*-unsigned.ipa
            beecount-*-signed.ipa
            beecount-*-iphonesimulator.app.zip

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs:
      - check-branch
      - android
      - ios
    if: always() && (needs.check-branch.result == 'success' || github.event_name == 'push') && needs.android.result == 'success' && needs.ios.result == 'success'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Ensure tags are fetched
        run: |
          git fetch --tags --force || true

      - name: Prepare release metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          IS_TAG="false"
          TAG_NAME=""
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            IS_TAG="true"
            TAG_NAME="${GITHUB_REF#refs/tags/}"
          fi
          if [[ -z "$TAG_NAME" ]]; then
            INPUT_TAG="${{ github.event.inputs.tag_name || '' }}"
            if [[ -n "$INPUT_TAG" ]]; then
              TAG_NAME="$INPUT_TAG"
            else
              SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-7)
              TAG_NAME="manual-${SHORT_SHA}"
            fi
          fi
          # æ‰‹åŠ¨è§¦å‘é»˜è®¤ prerelease=trueï¼›tag è§¦å‘é»˜è®¤ false
          INPUT_PRERELEASE="${{ github.event.inputs.prerelease || '' }}"
          if [[ "$IS_TAG" == "true" ]]; then
            PRERELEASE="false"
          else
            PRERELEASE=${INPUT_PRERELEASE:-true}
          fi
          # æ˜¯å¦åˆ›å»º Release
          INPUT_CREATE="${{ github.event.inputs.create_release || '' }}"
          if [[ "$IS_TAG" == "true" ]]; then
            CREATE_RELEASE="true"
          else
            CREATE_RELEASE=${INPUT_CREATE:-false}
          fi
          RELEASE_NAME_INPUT="${{ github.event.inputs.release_name || '' }}"
          if [[ -n "$RELEASE_NAME_INPUT" ]]; then
            RELEASE_NAME="$RELEASE_NAME_INPUT"
          else
            RELEASE_NAME="$TAG_NAME"
          fi
          echo "is_tag=$IS_TAG" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "prerelease=$PRERELEASE" >> $GITHUB_OUTPUT
          echo "create_release=$CREATE_RELEASE" >> $GITHUB_OUTPUT
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
      - name: Download Android artifacts
        uses: actions/download-artifact@v4
        with:
          name: android
          path: ./dist/android

      - name: List downloaded artifacts (debug)
        run: |
          echo "== dist tree =="
          ls -R ./dist || true

      - name: Download iOS artifacts
        uses: actions/download-artifact@v4
        with:
          name: ios
          path: ./dist/ios

      - name: Generate release notes
        id: notes
        run: |
          TAG="${{ steps.meta.outputs.tag_name }}"
          # è·å–ä¸Šä¸€ä¸ª tagï¼ˆä¸å«å½“å‰ tagï¼‰
          PREV_TAG=$(git tag --list --sort=-version:refname | grep -v "^${TAG}$" | head -n1)
          echo "Current tag: $TAG"
          echo "Previous tag: $PREV_TAG"
          # ç”Ÿæˆ commit åˆ—è¡¨ï¼ˆæ’é™¤ merge commitï¼‰
          if [ -n "$PREV_TAG" ]; then
            echo "Generating commit log from $PREV_TAG to HEAD"
            COMMITS=$(git log --no-merges --pretty=format:"- %s ([%h](https://github.com/${GITHUB_REPOSITORY}/commit/%H))" "$PREV_TAG"..HEAD)
          else
            echo "No previous tag found, showing all commits"
            COMMITS=$(git log --no-merges --pretty=format:"- %s ([%h](https://github.com/${GITHUB_REPOSITORY}/commit/%H))")
          fi
          cat > RELEASE_NOTES.md <<EOF

          ## å˜æ›´è®°å½•
          $COMMITS

          EOF
          echo "notes_file=RELEASE_NOTES.md" >> $GITHUB_OUTPUT

      - name: Create Release
        if: ${{ steps.meta.outputs.create_release == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.meta.outputs.tag_name }}
          name: ${{ steps.meta.outputs.release_name }}
          prerelease: ${{ steps.meta.outputs.prerelease == 'true' }}
          body_path: ${{ steps.notes.outputs.notes_file }}
          files: |
            dist/android/**/*.apk
            dist/android/**/*.aab
            dist/ios/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Send Telegram notification
        if: ${{ steps.meta.outputs.create_release == 'true' }}
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          TAG="${{ steps.meta.outputs.tag_name }}"
          RELEASE_URL="https://github.com/${GITHUB_REPOSITORY}/releases/tag/${TAG}"
          IS_PRERELEASE="${{ steps.meta.outputs.prerelease }}"

          # è·å– commit å˜æ›´åˆ—è¡¨ï¼ˆä¸ release notes ç›¸åŒï¼‰
          PREV_TAG=$(git tag --list --sort=-version:refname | grep -v "^${TAG}$" | head -n1)
          if [ -n "$PREV_TAG" ]; then
            COMMITS=$(git log --no-merges --pretty=format:"- %s" "$PREV_TAG"..HEAD)
          else
            COMMITS=$(git log --no-merges --pretty=format:"- %s")
          fi

          # è½¬ä¹‰ Markdown ç‰¹æ®Šå­—ç¬¦ï¼Œç„¶åè¿›è¡Œ URL ç¼–ç 
          COMMITS_ESCAPED=$(echo "$COMMITS" | sed 's/\*/\\*/g; s/_/\\_/g; s/\[/\\[/g; s/\]/\\]/g; s/`/\\`/g')
          # URL ç¼–ç å˜æ›´å†…å®¹ï¼ˆæ¢è¡Œç¬¦è½¬ä¸º %0Aï¼‰
          COMMITS_ENCODED=$(echo "$COMMITS_ESCAPED" | sed 's/$/%0A/g' | tr -d '\n')

          # æ„å»ºæ¶ˆæ¯
          if [ "$IS_PRERELEASE" == "true" ]; then
            MESSAGE="ğŸ *BeeCount ${TAG}* å‘å¸ƒï¼ˆé¢„è§ˆç‰ˆï¼‰%0A%0A"
          else
            MESSAGE="ğŸ *BeeCount ${TAG}* å‘å¸ƒ%0A%0A"
          fi

          MESSAGE="${MESSAGE}ğŸ”— [æŸ¥çœ‹å®Œæ•´è¯´æ˜](${RELEASE_URL})%0A%0A"
          MESSAGE="${MESSAGE}*å˜æ›´å†…å®¹*:%0A${COMMITS_ENCODED}"

          # å‘é€åˆ° Telegram
          if [ -n "${TELEGRAM_BOT_TOKEN:-}" ] && [ -n "${TELEGRAM_CHAT_ID:-}" ]; then
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d "chat_id=${TELEGRAM_CHAT_ID}" \
              -d "text=${MESSAGE}" \
              -d "parse_mode=Markdown" \
              -d "disable_web_page_preview=true"
            echo "âœ… Telegram notification sent successfully!"
          else
            echo "âš ï¸  Telegram credentials not configured, skipping notification"
          fi
